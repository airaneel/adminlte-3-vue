{
  "events": [
    {
      "event": "call",
      "http_server_request": {
        "path_info": "/@vite/client",
        "request_method": "GET",
        "headers": {
          "Host": "localhost:5173",
          "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:128.0) Gecko/20100101 Firefox/128.0",
          "Accept": "*/*",
          "Accept-Language": "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3",
          "Accept-Encoding": "gzip, deflate, br, zstd",
          "Connection": "keep-alive",
          "Referer": "http://localhost:5173/regru",
          "Cookie": "csrftoken=JoG0lboZVZucsyUC10B83fyK2PSrJqgf; _pk_id.1.1fff=76aff4dcfa6d42d0.1719754794.; accessToken=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNzIwMzczOTQ1LCJpYXQiOjE3MjAzNzM2NDUsImp0aSI6IjkyYjQzYmVjZjYxOTQyYTg5NDNjNWU2OGVjMDllYTQ3IiwidXNlcl9pZCI6MX0.9q_idMkvw61A5G6GQkM1WGfNo-jUZdncjM_JDqPh1Ps; refreshToken=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTcyMDQ2MDA0NSwiaWF0IjoxNzIwMzczNjQ1LCJqdGkiOiIwODJmMTYzMDEwNWY0YmViYTE2MjZjNjI5Y2U0ODFkMSIsInVzZXJfaWQiOjF9.Kh6m-J9pRfNqxauGr3E2UcLozG_px7iFCtCHeCHGb8I; tabstyle=html-tab; vuexy-color-scheme=dark; vuexy-isVerticalNavCollapsed=false; r-color-scheme=dark; rh-color-scheme=dark; rdh-color-scheme=dark; rdh--color-scheme=dark; rdh-corp-color-scheme=dark; rdh-corporte-color-scheme=dark; rdh-corporate-color-scheme=dark; rRD-corporate-color-scheme=dark; -corporate-color-scheme=dark; RDH-corporate-color-scheme=dark; RDH-corporate-isVerticalNavCollapsed=true; RDH-color-scheme=dark; -color-scheme=dark; R-color-scheme=dark; RDH-theme=light; RDH-corporate-theme=dark",
          "Sec-Fetch-Dest": "script",
          "Sec-Fetch-Mode": "cors",
          "Sec-Fetch-Site": "same-origin",
          "Pragma": "no-cache",
          "Cache-Control": "no-cache"
        },
        "protocol": "HTTP/1.1"
      },
      "id": 1,
      "thread_id": 0
    },
    {
      "event": "return",
      "http_server_response": {
        "status_code": 200,
        "headers": {
          "Access-Control-Allow-Origin": "*",
          "Content-Type": "text/javascript",
          "Cache-Control": "no-cache",
          "Etag": "W/\"5c85-NO+J/uooGGPl3VN1mXcPIIMmiEk\""
        },
        "return_value": {
          "class": "[ResponseBody]",
          "value": "import \"/node_modules/vite/dist/client/env.mjs\";\n\nclass HMRContext {\n  constructor(hmrClient, ownerPath) {\n    this.hmrClient = hmrClient;\n    this.ownerPath = ownerPath;\n    if (!hmrClient.dataMap.has(ownerPath)) {\n      hmrClient.dataMap.set(ownerPath, {});\n    }\n    const mod = hmrClient.hotModulesMap.get(ownerPath);\n    if (mod) {\n      mod.callbacks = [];\n    }\n    const staleListeners = hmrClient.ctxToListenersMap.get(ownerPath);\n    if (staleListeners) {\n      for (const [event, staleFns] of staleListeners) {\n        const listeners = hmrClient.customListenersMap.get(event);\n        if (listeners) {\n          hmrClient.customListenersMap.set(\n            event,\n            listeners.filter((l) => !staleFns.includes(l))\n          );\n        }\n      }\n    }\n    this.newListeners = /* @__PURE__ */ new Map();\n    hmrClient.ctxToListenersMap.set(ownerPath, this.newListeners);\n  }\n  get data() {\n    return this.hmrClient.dataMap.get(this.ownerPath);\n  }\n  accept(deps, callback) {\n    if (typeof deps === \"function\" || !deps) {\n      this.acceptDeps([this.ownerPath], ([mod]) => deps?.(mod));\n    } else if (typeof deps === \"string\") {\n      this.acceptDeps([deps], ([mod]) => callback?.(mod));\n    } else if (Array.isArray(deps)) {\n      this.acceptDeps(deps, callback);\n    } else {\n      throw new Error(`invalid hot.accept() usage.`);\n    }\n  }\n  // export names (first arg) are irrelevant on the client side, they're\n  // extracted in the server for propagation\n  acceptExports(_, callback) {\n    this.acceptDeps([this.ownerPath], ([mod]) => callback?.(mod));\n  }\n  dispose(cb) {\n    this.hmrClient.disposeMap.set(this.ownerPath, cb);\n  }\n  prune(cb) {\n    this.hmrClient.pruneMap.set(this.ownerPath, cb);\n  }\n  // Kept for backward compatibility (#11036)\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  decline() {\n  }\n  invalidate(message) {\n    this.hmrClient.notifyListeners(\"vite:invalidate\", {\n      path: this.ownerPath,\n      message\n    });\n    this.send(\"vite:invalidate\", { path: this.ownerPath, message });\n    this.hmrClient.logger.debug(\n      `[vite] invalidate ${this.ownerPath}${message ? `: ${message}` : \"\"}`\n    );\n  }\n  on(event, cb) {\n    const addToMap = (map) => {\n      const existing = map.get(event) || [];\n      existing.push(cb);\n      map.set(event, existing);\n    };\n    addToMap(this.hmrClient.customListenersMap);\n    addToMap(this.newListeners);\n  }\n  off(event, cb) {\n    const removeFromMap = (map) => {\n      const existing = map.get(event);\n      if (existing === void 0) {\n        return;\n      }\n      const pruned = existing.filter((l) => l !== cb);\n      if (pruned.length === 0) {\n        map.delete(event);\n        return;\n      }\n      map.set(event, pruned);\n    };\n    removeFromMap(this.hmrClient.customListenersMap);\n    removeFromMap(this.newListeners);\n  }\n  send(event, data) {\n    this.hmrClient.messenger.send(\n      JSON.stringify({ type: \"custom\", event, data })\n    );\n  }\n  acceptDeps(deps, callback = () => {\n  }) {\n    const mod = this.hmrClient.hotModulesMap.get(this.ownerPath) || {\n      id: this.ownerPath,\n      callbacks: []\n    };\n    mod.callbacks.push({\n      deps,\n      fn: callback\n    });\n    this.hmrClient.hotModulesMap.set(this.ownerPath, mod);\n  }\n}\nclass HMRMessenger {\n  constructor(connection) {\n    this.connection = connection;\n    this.queue = [];\n  }\n  send(message) {\n    this.queue.push(message);\n    this.flush();\n  }\n  flush() {\n    if (this.connection.isReady()) {\n      this.queue.forEach((msg) => this.connection.send(msg));\n      this.queue = [];\n    }\n  }\n}\nclass HMRClient {\n  constructor(logger, connection, importUpdatedModule) {\n    this.logger = logger;\n    this.importUpdatedModule = importUpdatedModule;\n    this.hotModulesMap = /* @__PURE__ */ new Map();\n    this.disposeMap = /* @__PURE__ */ new Map();\n    this.pruneMap = /* @__PURE__ */ new Map();\n    this.dataMap = /* @__PURE__ */ new Map();\n    this.customListenersMap = /* @__PURE__ */ new Map();\n    this.ctxToListenersMap = /* @__PURE__ */ new Map();\n    this.updateQueue = [];\n    this.pendingUpdateQueue = false;\n    this.messenger = new HMRMessenger(connection);\n  }\n  async notifyListeners(event, data) {\n    const cbs = this.customListenersMap.get(event);\n    if (cbs) {\n      await Promise.allSettled(cbs.map((cb) => cb(data)));\n    }\n  }\n  clear() {\n    this.hotModulesMap.clear();\n    this.disposeMap.clear();\n    this.pruneMap.clear();\n    this.dataMap.clear();\n    this.customListenersMap.clear();\n    this.ctxToListenersMap.clear();\n  }\n  // After an HMR update, some modules are no longer imported on the page\n  // but they may have left behind side effects that need to be cleaned up\n  // (.e.g style injections)\n  async prunePaths(paths) {\n    await Promise.all(\n      paths.map((path) => {\n        const disposer = this.disposeMap.get(path);\n        if (disposer) return disposer(this.dataMap.get(path));\n      })\n    );\n    paths.forEach((path) => {\n      const fn = this.pruneMap.get(path);\n      if (fn) {\n        fn(this.dataMap.get(path));\n      }\n    });\n  }\n  warnFailedUpdate(err, path) {\n    if (!err.message.includes(\"fetch\")) {\n      this.logger.error(err);\n    }\n    this.logger.error(\n      `[hmr] Failed to reload ${path}. This could be due to syntax errors or importing non-existent modules. (see errors above)`\n    );\n  }\n  /**\n   * buffer multiple hot updates triggered by the same src change\n   * so that they are invoked in the same order they were sent.\n   * (otherwise the order may be inconsistent because of the http request round trip)\n   */\n  async queueUpdate(payload) {\n    this.updateQueue.push(this.fetchUpdate(payload));\n    if (!this.pendingUpdateQueue) {\n      this.pendingUpdateQueue = true;\n      await Promise.resolve();\n      this.pendingUpdateQueue = false;\n      const loading = [...this.updateQueue];\n      this.updateQueue = [];\n      (await Promise.all(loading)).forEach((fn) => fn && fn());\n    }\n  }\n  async fetchUpdate(update) {\n    const { path, acceptedPath } = update;\n    const mod = this.hotModulesMap.get(path);\n    if (!mod) {\n      return;\n    }\n    let fetchedModule;\n    const isSelfUpdate = path === acceptedPath;\n    const qualifiedCallbacks = mod.callbacks.filter(\n      ({ deps }) => deps.includes(acceptedPath)\n    );\n    if (isSelfUpdate || qualifiedCallbacks.length > 0) {\n      const disposer = this.disposeMap.get(acceptedPath);\n      if (disposer) await disposer(this.dataMap.get(acceptedPath));\n      try {\n        fetchedModule = await this.importUpdatedModule(update);\n      } catch (e) {\n        this.warnFailedUpdate(e, acceptedPath);\n      }\n    }\n    return () => {\n      for (const { deps, fn } of qualifiedCallbacks) {\n        fn(\n          deps.map((dep) => dep === acceptedPath ? fetchedModule : void 0)\n        );\n      }\n      const loggedPath = isSelfUpdate ? path : `${acceptedPath} via ${path}`;\n      this.logger.debug(`[vite] hot updated: ${loggedPath}`);\n    };\n  }\n}\n\nconst hmrConfigName = \"vite.config.ts\";\nconst base$1 = \"/\" || \"/\";\nfunction h(e, attrs = {}, ...children) {\n  const elem = document.createElement(e);\n  for (const [k, v] of Object.entries(attrs)) {\n    elem.setAttribute(k, v);\n  }\n  elem.append(...children);\n  return elem;\n}\nconst templateStyle = (\n  /*css*/\n  `\n:host {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 99999;\n  --monospace: 'SFMono-Regular', Consolas,\n  'Liberation Mono', Menlo, Courier, monospace;\n  --red: #ff5555;\n  --yellow: #e2aa53;\n  --purple: #cfa4ff;\n  --cyan: #2dd9da;\n  --dim: #c9c9c9;\n\n  --window-background: #181818;\n  --window-color: #d8d8d8;\n}\n\n.backdrop {\n  position: fixed;\n  z-index: 99999;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  overflow-y: scroll;\n  margin: 0;\n  background: rgba(0, 0, 0, 0.66);\n}\n\n.window {\n  font-family: var(--monospace);\n  line-height: 1.5;\n  max-width: 80vw;\n  color: var(--window-color);\n  box-sizing: border-box;\n  margin: 30px auto;\n  padding: 2.5vh 4vw;\n  position: relative;\n  background: var(--window-background);\n  border-radius: 6px 6px 8px 8px;\n  box-shadow: 0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22);\n  overflow: hidden;\n  border-top: 8px solid var(--red);\n  direction: ltr;\n  text-align: left;\n}\n\npre {\n  font-family: var(--monospace);\n  font-size: 16px;\n  margin-top: 0;\n  margin-bottom: 1em;\n  overflow-x: scroll;\n  scrollbar-width: none;\n}\n\npre::-webkit-scrollbar {\n  display: none;\n}\n\npre.frame::-webkit-scrollbar {\n  display: block;\n  height: 5px;\n}\n\npre.frame::-webkit-scrollbar-thumb {\n  background: #999;\n  border-radius: 5px;\n}\n\npre.frame {\n  scrollbar-width: thin;\n}\n\n.message {\n  line-height: 1.3;\n  font-weight: 600;\n  white-space: pre-wrap;\n}\n\n.message-body {\n  color: var(--red);\n}\n\n.plugin {\n  color: var(--purple);\n}\n\n.file {\n  color: var(--cyan);\n  margin-bottom: 0;\n  white-space: pre-wrap;\n  word-break: break-all;\n}\n\n.frame {\n  color: var(--yellow);\n}\n\n.stack {\n  font-size: 13px;\n  color: var(--dim);\n}\n\n.tip {\n  font-size: 13px;\n  color: #999;\n  border-top: 1px dotted #999;\n  padding-top: 13px;\n  line-height: 1.8;\n}\n\ncode {\n  font-size: 13px;\n  font-family: var(--monospace);\n  color: var(--yellow);\n}\n\n.file-link {\n  text-decoration: underline;\n  cursor: pointer;\n}\n\nkbd {\n  line-height: 1.5;\n  font-family: ui-monospace, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n  font-size: 0.75rem;\n  font-weight: 700;\n  background-color: rgb(38, 40, 44);\n  color: rgb(166, 167, 171);\n  padding: 0.15rem 0.3rem;\n  border-radius: 0.25rem;\n  border-width: 0.0625rem 0.0625rem 0.1875rem;\n  border-style: solid;\n  border-color: rgb(54, 57, 64);\n  border-image: initial;\n}\n`\n);\nconst createTemplate = () => h(\n  \"div\",\n  { class: \"backdrop\", part: \"backdrop\" },\n  h(\n    \"div\",\n    { class: \"window\", part: \"window\" },\n    h(\n      \"pre\",\n      { class: \"message\", part: \"message\" },\n      h(\"span\", { class: \"plugin\", part: \"plugin\" }),\n      h(\"span\", { class: \"message-body\", part: \"message-body\" })\n    ),\n... (127392 more characters)"
        }
      },
      "id": 2,
      "thread_id": 0,
      "parent_id": 1,
      "elapsed": 0.010550749997491948
    }
  ],
  "version": "1.12",
  "metadata": {
    "client": {
      "name": "appmap-node",
      "version": "2.23.0",
      "url": "https://github.com/getappmap/appmap-node"
    },
    "language": {
      "name": "javascript",
      "engine": "Node.js",
      "version": "v20.11.1"
    },
    "app": "rdh-admin",
    "recorder": {
      "type": "requests",
      "name": "requests"
    },
    "name": "GET /@vite/client (200) — 2024-07-13T13:08:26.803Z"
  },
  "classMap": [
    {
      "type": "http",
      "name": "HTTP server requests",
      "children": [
        {
          "type": "route",
          "name": "GET /@vite/client"
        }
      ]
    }
  ]
}