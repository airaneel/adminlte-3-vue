{
  "events": [
    {
      "event": "call",
      "http_server_request": {
        "path_info": "/node_modules/.vite/deps/@profabric_vue-components.js",
        "request_method": "GET",
        "headers": {
          "Host": "localhost:5173",
          "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:128.0) Gecko/20100101 Firefox/128.0",
          "Accept": "*/*",
          "Accept-Language": "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3",
          "Accept-Encoding": "gzip, deflate, br, zstd",
          "Connection": "keep-alive",
          "Referer": "http://localhost:5173/src/main.ts",
          "Cookie": "csrftoken=JoG0lboZVZucsyUC10B83fyK2PSrJqgf; _pk_id.1.1fff=76aff4dcfa6d42d0.1719754794.; accessToken=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNzIwMzczOTQ1LCJpYXQiOjE3MjAzNzM2NDUsImp0aSI6IjkyYjQzYmVjZjYxOTQyYTg5NDNjNWU2OGVjMDllYTQ3IiwidXNlcl9pZCI6MX0.9q_idMkvw61A5G6GQkM1WGfNo-jUZdncjM_JDqPh1Ps; refreshToken=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTcyMDQ2MDA0NSwiaWF0IjoxNzIwMzczNjQ1LCJqdGkiOiIwODJmMTYzMDEwNWY0YmViYTE2MjZjNjI5Y2U0ODFkMSIsInVzZXJfaWQiOjF9.Kh6m-J9pRfNqxauGr3E2UcLozG_px7iFCtCHeCHGb8I; tabstyle=html-tab; vuexy-color-scheme=dark; vuexy-isVerticalNavCollapsed=false; r-color-scheme=dark; rh-color-scheme=dark; rdh-color-scheme=dark; rdh--color-scheme=dark; rdh-corp-color-scheme=dark; rdh-corporte-color-scheme=dark; rdh-corporate-color-scheme=dark; rRD-corporate-color-scheme=dark; -corporate-color-scheme=dark; RDH-corporate-color-scheme=dark; RDH-corporate-isVerticalNavCollapsed=true; RDH-color-scheme=dark; -color-scheme=dark; R-color-scheme=dark; RDH-theme=light; RDH-corporate-theme=dark",
          "Sec-Fetch-Dest": "script",
          "Sec-Fetch-Mode": "cors",
          "Sec-Fetch-Site": "same-origin",
          "Pragma": "no-cache",
          "Cache-Control": "no-cache"
        },
        "protocol": "HTTP/1.1"
      },
      "id": 1,
      "thread_id": 0,
      "message": [
        {
          "name": "v",
          "value": "'e79d9748'",
          "class": "String"
        }
      ]
    },
    {
      "event": "return",
      "http_server_response": {
        "status_code": 200,
        "headers": {
          "Access-Control-Allow-Origin": "*",
          "Content-Type": "text/javascript",
          "Cache-Control": "max-age=31536000,immutable",
          "Etag": "W/\"11f10-hp21aBLUxCThTk7bP2/VTnkAvFU\""
        },
        "return_value": {
          "class": "[ResponseBody]",
          "value": "import {\n  defineComponent,\n  getCurrentInstance,\n  h,\n  inject,\n  ref\n} from \"/node_modules/.vite/deps/chunk-MGOCPVRW.js?v=e79d9748\";\nimport \"/node_modules/.vite/deps/chunk-G3PMV62Z.js?v=e79d9748\";\n\n// node_modules/@profabric/web-components/dist/index.js\nvar et = globalThis;\nvar ut = et.ShadowRoot && (et.ShadyCSS === void 0 || et.ShadyCSS.nativeShadow) && \"adoptedStyleSheets\" in Document.prototype && \"replace\" in CSSStyleSheet.prototype;\nvar Ot = Symbol();\nvar vt = /* @__PURE__ */ new WeakMap();\nvar Lt = class {\n  constructor(t, e, r) {\n    if (this._$cssResult$ = true, r !== Ot)\n      throw Error(\"CSSResult is not constructable. Use `unsafeCSS` or `css` instead.\");\n    this.cssText = t, this.t = e;\n  }\n  get styleSheet() {\n    let t = this.o;\n    const e = this.t;\n    if (ut && t === void 0) {\n      const r = e !== void 0 && e.length === 1;\n      r && (t = vt.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), r && vt.set(e, t));\n    }\n    return t;\n  }\n  toString() {\n    return this.cssText;\n  }\n};\nvar A = (i) => new Lt(typeof i == \"string\" ? i : i + \"\", void 0, Ot);\nvar jt = (i, t) => {\n  if (ut)\n    i.adoptedStyleSheets = t.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet);\n  else\n    for (const e of t) {\n      const r = document.createElement(\"style\"), o = et.litNonce;\n      o !== void 0 && r.setAttribute(\"nonce\", o), r.textContent = e.cssText, i.appendChild(r);\n    }\n};\nvar yt = ut ? (i) => i : (i) => i instanceof CSSStyleSheet ? ((t) => {\n  let e = \"\";\n  for (const r of t.cssRules)\n    e += r.cssText;\n  return A(e);\n})(i) : i;\nvar { is: It, defineProperty: Wt, getOwnPropertyDescriptor: Yt, getOwnPropertyNames: Ft, getOwnPropertySymbols: Vt, getPrototypeOf: qt } = Object;\nvar O = globalThis;\nvar $t = O.trustedTypes;\nvar Jt = $t ? $t.emptyScript : \"\";\nvar nt = O.reactiveElementPolyfillSupport;\nvar Y = (i, t) => i;\nvar rt = { toAttribute(i, t) {\n  switch (t) {\n    case Boolean:\n      i = i ? Jt : null;\n      break;\n    case Object:\n    case Array:\n      i = i == null ? i : JSON.stringify(i);\n  }\n  return i;\n}, fromAttribute(i, t) {\n  let e = i;\n  switch (t) {\n    case Boolean:\n      e = i !== null;\n      break;\n    case Number:\n      e = i === null ? null : Number(i);\n      break;\n    case Object:\n    case Array:\n      try {\n        e = JSON.parse(i);\n      } catch {\n        e = null;\n      }\n  }\n  return e;\n} };\nvar ft = (i, t) => !It(i, t);\nvar wt = { attribute: true, type: String, converter: rt, reflect: false, hasChanged: ft };\nSymbol.metadata ?? (Symbol.metadata = Symbol(\"metadata\")), O.litPropertyMetadata ?? (O.litPropertyMetadata = /* @__PURE__ */ new WeakMap());\nvar H = class extends HTMLElement {\n  static addInitializer(t) {\n    this._$Ei(), (this.l ?? (this.l = [])).push(t);\n  }\n  static get observedAttributes() {\n    return this.finalize(), this._$Eh && [...this._$Eh.keys()];\n  }\n  static createProperty(t, e = wt) {\n    if (e.state && (e.attribute = false), this._$Ei(), this.elementProperties.set(t, e), !e.noAccessor) {\n      const r = Symbol(), o = this.getPropertyDescriptor(t, r, e);\n      o !== void 0 && Wt(this.prototype, t, o);\n    }\n  }\n  static getPropertyDescriptor(t, e, r) {\n    const { get: o, set: s } = Yt(this.prototype, t) ?? { get() {\n      return this[e];\n    }, set(n) {\n      this[e] = n;\n    } };\n    return { get() {\n      return o == null ? void 0 : o.call(this);\n    }, set(n) {\n      const c = o == null ? void 0 : o.call(this);\n      s.call(this, n), this.requestUpdate(t, c, r);\n    }, configurable: true, enumerable: true };\n  }\n  static getPropertyOptions(t) {\n    return this.elementProperties.get(t) ?? wt;\n  }\n  static _$Ei() {\n    if (this.hasOwnProperty(Y(\"elementProperties\")))\n      return;\n    const t = qt(this);\n    t.finalize(), t.l !== void 0 && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);\n  }\n  static finalize() {\n    if (this.hasOwnProperty(Y(\"finalized\")))\n      return;\n    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(Y(\"properties\"))) {\n      const e = this.properties, r = [...Ft(e), ...Vt(e)];\n      for (const o of r)\n        this.createProperty(o, e[o]);\n    }\n    const t = this[Symbol.metadata];\n    if (t !== null) {\n      const e = litPropertyMetadata.get(t);\n      if (e !== void 0)\n        for (const [r, o] of e)\n          this.elementProperties.set(r, o);\n    }\n    this._$Eh = /* @__PURE__ */ new Map();\n    for (const [e, r] of this.elementProperties) {\n      const o = this._$Eu(e, r);\n      o !== void 0 && this._$Eh.set(o, e);\n    }\n    this.elementStyles = this.finalizeStyles(this.styles);\n  }\n  static finalizeStyles(t) {\n    const e = [];\n    if (Array.isArray(t)) {\n      const r = new Set(t.flat(1 / 0).reverse());\n      for (const o of r)\n        e.unshift(yt(o));\n    } else\n      t !== void 0 && e.push(yt(t));\n    return e;\n  }\n  static _$Eu(t, e) {\n    const r = e.attribute;\n    return r === false ? void 0 : typeof r == \"string\" ? r : typeof t == \"string\" ? t.toLowerCase() : void 0;\n  }\n  constructor() {\n    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();\n  }\n  _$Ev() {\n    var t;\n    this._$ES = new Promise((e) => this.enableUpdating = e), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (t = this.constructor.l) == null || t.forEach((e) => e(this));\n  }\n  addController(t) {\n    var e;\n    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(t), this.renderRoot !== void 0 && this.isConnected && ((e = t.hostConnected) == null || e.call(t));\n  }\n  removeController(t) {\n    var e;\n    (e = this._$EO) == null || e.delete(t);\n  }\n  _$E_() {\n    const t = /* @__PURE__ */ new Map(), e = this.constructor.elementProperties;\n    for (const r of e.keys())\n      this.hasOwnProperty(r) && (t.set(r, this[r]), delete this[r]);\n    t.size > 0 && (this._$Ep = t);\n  }\n  createRenderRoot() {\n    const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);\n    return jt(t, this.constructor.elementStyles), t;\n  }\n  connectedCallback() {\n    var t;\n    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), (t = this._$EO) == null || t.forEach((e) => {\n      var r;\n      return (r = e.hostConnected) == null ? void 0 : r.call(e);\n    });\n  }\n  enableUpdating(t) {\n  }\n  disconnectedCallback() {\n    var t;\n    (t = this._$EO) == null || t.forEach((e) => {\n      var r;\n      return (r = e.hostDisconnected) == null ? void 0 : r.call(e);\n    });\n  }\n  attributeChangedCallback(t, e, r) {\n    this._$AK(t, r);\n  }\n  _$EC(t, e) {\n    var s;\n    const r = this.constructor.elementProperties.get(t), o = this.constructor._$Eu(t, r);\n    if (o !== void 0 && r.reflect === true) {\n      const n = (((s = r.converter) == null ? void 0 : s.toAttribute) !== void 0 ? r.converter : rt).toAttribute(e, r.type);\n      this._$Em = t, n == null ? this.removeAttribute(o) : this.setAttribute(o, n), this._$Em = null;\n    }\n  }\n  _$AK(t, e) {\n    var s;\n    const r = this.constructor, o = r._$Eh.get(t);\n    if (o !== void 0 && this._$Em !== o) {\n      const n = r.getPropertyOptions(o), c = typeof n.converter == \"function\" ? { fromAttribute: n.converter } : ((s = n.converter) == null ? void 0 : s.fromAttribute) !== void 0 ? n.converter : rt;\n      this._$Em = o, this[o] = c.fromAttribute(e, n.type), this._$Em = null;\n    }\n  }\n  requestUpdate(t, e, r) {\n    if (t !== void 0) {\n      if (r ?? (r = this.constructor.getPropertyOptions(t)), !(r.hasChanged ?? ft)(this[t], e))\n        return;\n      this.P(t, e, r);\n    }\n    this.isUpdatePending === false && (this._$ES = this._$ET());\n  }\n  P(t, e, r) {\n    this._$AL.has(t) || this._$AL.set(t, e), r.reflect === true && this._$Em !== t && (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(t);\n  }\n  async _$ET() {\n    this.isUpdatePending = true;\n    try {\n      await this._$ES;\n    } catch (e) {\n      Promise.reject(e);\n    }\n    const t = this.scheduleUpdate();\n    return t != null && await t, !this.isUpdatePending;\n  }\n  scheduleUpdate() {\n    return this.performUpdate();\n  }\n  performUpdate() {\n    var r;\n    if (!this.isUpdatePending)\n      return;\n    if (!this.hasUpdated) {\n      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {\n        for (const [s, n] of this._$Ep)\n          this[s] = n;\n        this._$Ep = void 0;\n      }\n      const o = this.constructor.elementProperties;\n      if (o.size > 0)\n        for (const [s, n] of o)\n          n.wrapped !== true || this._$AL.has(s) || this[s] === void 0 || this.P(s, this[s], n);\n    }\n    let t = false;\n    const e = this._$AL;\n    try {\n      t = this.shouldUpdate(e), t ? (this.willUpdate(e), (r = this._$EO) == null || r.forEach((o) => {\n        var s;\n        return (s = o.hostUpdate) == null ? void 0 : s.call(o);\n      }), this.update(e)) : this._$EU();\n    } catch (o) {\n      throw t = false, this._$EU(), o;\n    }\n    t && this._$AE(e);\n  }\n  willUpdate(t) {\n  }\n  _$AE(t) {\n    var e;\n    (e = this._$EO) == null || e.forEach((r) => {\n      var o;\n      return (o = r.hostUpdated) == null ? void 0 : o.call(r);\n    }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t)), this.updated(t);\n  }\n  _$EU() {\n    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;\n  }\n  get updateComplete() {\n    return this.getUpdateComplete();\n  }\n  getUpdateComplete() {\n    return this._$ES;\n  }\n  shouldUpdate(t) {\n    return true;\n  }\n  update(t) {\n    this._$Ej && (this._$Ej = this._$Ej.forEach((e) => this._$EC(e, this[e]))), this._$EU();\n  }\n  updated(t) {\n  }\n  firstUpdated(t) {\n  }\n};\nH.elementStyles = [], H.shadowRootOptions = { mode: \"open\" }, H[Y(\"elementProperties\")] = /* @__PURE__ */ new Map(), H[Y(\"finalized\")] = /* @__PURE__ */ new Map(), nt == null || nt({ ReactiveElement: H }), (O.reactiveElementVersions ?? (O.reactiveElementVersions = [])).push(\"2.0.4\");\nvar F = globalThis;\nvar it = F.trustedTypes;\nvar _... (63488 more characters)"
        }
      },
      "id": 2,
      "thread_id": 0,
      "parent_id": 1,
      "elapsed": 0.0003117079904768616
    }
  ],
  "version": "1.12",
  "metadata": {
    "client": {
      "name": "appmap-node",
      "version": "2.23.0",
      "url": "https://github.com/getappmap/appmap-node"
    },
    "language": {
      "name": "javascript",
      "engine": "Node.js",
      "version": "v20.11.1"
    },
    "app": "rdh-admin",
    "recorder": {
      "type": "requests",
      "name": "requests"
    },
    "name": "GET /node_modules/.vite/deps/@profabric_vue-components.js (200) — 2024-07-13T11:51:51.258Z"
  },
  "classMap": [
    {
      "type": "http",
      "name": "HTTP server requests",
      "children": [
        {
          "type": "route",
          "name": "GET /node_modules/.vite/deps/@profabric_vue-components.js"
        }
      ]
    }
  ]
}