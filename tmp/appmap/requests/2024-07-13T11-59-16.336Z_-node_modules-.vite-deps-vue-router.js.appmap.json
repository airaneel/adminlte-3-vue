{
  "events": [
    {
      "event": "call",
      "http_server_request": {
        "path_info": "/node_modules/.vite/deps/vue-router.js",
        "request_method": "GET",
        "headers": {
          "Host": "localhost:5173",
          "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:128.0) Gecko/20100101 Firefox/128.0",
          "Accept": "*/*",
          "Accept-Language": "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3",
          "Accept-Encoding": "gzip, deflate, br, zstd",
          "Connection": "keep-alive",
          "Referer": "http://localhost:5173/src/router/index.ts",
          "Cookie": "csrftoken=JoG0lboZVZucsyUC10B83fyK2PSrJqgf; _pk_id.1.1fff=76aff4dcfa6d42d0.1719754794.; accessToken=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNzIwMzczOTQ1LCJpYXQiOjE3MjAzNzM2NDUsImp0aSI6IjkyYjQzYmVjZjYxOTQyYTg5NDNjNWU2OGVjMDllYTQ3IiwidXNlcl9pZCI6MX0.9q_idMkvw61A5G6GQkM1WGfNo-jUZdncjM_JDqPh1Ps; refreshToken=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTcyMDQ2MDA0NSwiaWF0IjoxNzIwMzczNjQ1LCJqdGkiOiIwODJmMTYzMDEwNWY0YmViYTE2MjZjNjI5Y2U0ODFkMSIsInVzZXJfaWQiOjF9.Kh6m-J9pRfNqxauGr3E2UcLozG_px7iFCtCHeCHGb8I; tabstyle=html-tab; vuexy-color-scheme=dark; vuexy-isVerticalNavCollapsed=false; r-color-scheme=dark; rh-color-scheme=dark; rdh-color-scheme=dark; rdh--color-scheme=dark; rdh-corp-color-scheme=dark; rdh-corporte-color-scheme=dark; rdh-corporate-color-scheme=dark; rRD-corporate-color-scheme=dark; -corporate-color-scheme=dark; RDH-corporate-color-scheme=dark; RDH-corporate-isVerticalNavCollapsed=true; RDH-color-scheme=dark; -color-scheme=dark; R-color-scheme=dark; RDH-theme=light; RDH-corporate-theme=dark",
          "Sec-Fetch-Dest": "script",
          "Sec-Fetch-Mode": "cors",
          "Sec-Fetch-Site": "same-origin",
          "Pragma": "no-cache",
          "Cache-Control": "no-cache"
        },
        "protocol": "HTTP/1.1"
      },
      "id": 1,
      "thread_id": 0,
      "message": [
        {
          "name": "v",
          "value": "'e79d9748'",
          "class": "String"
        }
      ]
    },
    {
      "event": "return",
      "http_server_response": {
        "status_code": 200,
        "headers": {
          "Access-Control-Allow-Origin": "*",
          "Content-Type": "text/javascript",
          "Cache-Control": "max-age=31536000,immutable",
          "Etag": "W/\"170af-sCii6X25KgP39tfddN6ZylB0fkQ\""
        },
        "return_value": {
          "class": "[ResponseBody]",
          "value": "import {\n  setupDevtoolsPlugin\n} from \"/node_modules/.vite/deps/chunk-YFT6OQ5R.js?v=e79d9748\";\nimport {\n  computed,\n  defineComponent,\n  getCurrentInstance,\n  h,\n  inject,\n  nextTick,\n  onActivated,\n  onDeactivated,\n  onUnmounted,\n  provide,\n  reactive,\n  ref,\n  shallowReactive,\n  shallowRef,\n  unref,\n  watch,\n  watchEffect\n} from \"/node_modules/.vite/deps/chunk-MGOCPVRW.js?v=e79d9748\";\nimport \"/node_modules/.vite/deps/chunk-G3PMV62Z.js?v=e79d9748\";\n\n// node_modules/vue-router/dist/vue-router.mjs\nvar isBrowser = typeof document !== \"undefined\";\nfunction isESModule(obj) {\n  return obj.__esModule || obj[Symbol.toStringTag] === \"Module\";\n}\nvar assign = Object.assign;\nfunction applyToParams(fn, params) {\n  const newParams = {};\n  for (const key in params) {\n    const value = params[key];\n    newParams[key] = isArray(value) ? value.map(fn) : fn(value);\n  }\n  return newParams;\n}\nvar noop = () => {\n};\nvar isArray = Array.isArray;\nfunction warn(msg) {\n  const args = Array.from(arguments).slice(1);\n  console.warn.apply(console, [\"[Vue Router warn]: \" + msg].concat(args));\n}\nvar HASH_RE = /#/g;\nvar AMPERSAND_RE = /&/g;\nvar SLASH_RE = /\\//g;\nvar EQUAL_RE = /=/g;\nvar IM_RE = /\\?/g;\nvar PLUS_RE = /\\+/g;\nvar ENC_BRACKET_OPEN_RE = /%5B/g;\nvar ENC_BRACKET_CLOSE_RE = /%5D/g;\nvar ENC_CARET_RE = /%5E/g;\nvar ENC_BACKTICK_RE = /%60/g;\nvar ENC_CURLY_OPEN_RE = /%7B/g;\nvar ENC_PIPE_RE = /%7C/g;\nvar ENC_CURLY_CLOSE_RE = /%7D/g;\nvar ENC_SPACE_RE = /%20/g;\nfunction commonEncode(text) {\n  return encodeURI(\"\" + text).replace(ENC_PIPE_RE, \"|\").replace(ENC_BRACKET_OPEN_RE, \"[\").replace(ENC_BRACKET_CLOSE_RE, \"]\");\n}\nfunction encodeHash(text) {\n  return commonEncode(text).replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryValue(text) {\n  return commonEncode(text).replace(PLUS_RE, \"%2B\").replace(ENC_SPACE_RE, \"+\").replace(HASH_RE, \"%23\").replace(AMPERSAND_RE, \"%26\").replace(ENC_BACKTICK_RE, \"`\").replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryKey(text) {\n  return encodeQueryValue(text).replace(EQUAL_RE, \"%3D\");\n}\nfunction encodePath(text) {\n  return commonEncode(text).replace(HASH_RE, \"%23\").replace(IM_RE, \"%3F\");\n}\nfunction encodeParam(text) {\n  return text == null ? \"\" : encodePath(text).replace(SLASH_RE, \"%2F\");\n}\nfunction decode(text) {\n  try {\n    return decodeURIComponent(\"\" + text);\n  } catch (err) {\n    warn(`Error decoding \"${text}\". Using original value`);\n  }\n  return \"\" + text;\n}\nvar TRAILING_SLASH_RE = /\\/$/;\nvar removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, \"\");\nfunction parseURL(parseQuery2, location2, currentLocation = \"/\") {\n  let path, query = {}, searchString = \"\", hash = \"\";\n  const hashPos = location2.indexOf(\"#\");\n  let searchPos = location2.indexOf(\"?\");\n  if (hashPos < searchPos && hashPos >= 0) {\n    searchPos = -1;\n  }\n  if (searchPos > -1) {\n    path = location2.slice(0, searchPos);\n    searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);\n    query = parseQuery2(searchString);\n  }\n  if (hashPos > -1) {\n    path = path || location2.slice(0, hashPos);\n    hash = location2.slice(hashPos, location2.length);\n  }\n  path = resolveRelativePath(path != null ? path : location2, currentLocation);\n  return {\n    fullPath: path + (searchString && \"?\") + searchString + hash,\n    path,\n    query,\n    hash: decode(hash)\n  };\n}\nfunction stringifyURL(stringifyQuery2, location2) {\n  const query = location2.query ? stringifyQuery2(location2.query) : \"\";\n  return location2.path + (query && \"?\") + query + (location2.hash || \"\");\n}\nfunction stripBase(pathname, base) {\n  if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))\n    return pathname;\n  return pathname.slice(base.length) || \"/\";\n}\nfunction isSameRouteLocation(stringifyQuery2, a, b) {\n  const aLastIndex = a.matched.length - 1;\n  const bLastIndex = b.matched.length - 1;\n  return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery2(a.query) === stringifyQuery2(b.query) && a.hash === b.hash;\n}\nfunction isSameRouteRecord(a, b) {\n  return (a.aliasOf || a) === (b.aliasOf || b);\n}\nfunction isSameRouteLocationParams(a, b) {\n  if (Object.keys(a).length !== Object.keys(b).length)\n    return false;\n  for (const key in a) {\n    if (!isSameRouteLocationParamsValue(a[key], b[key]))\n      return false;\n  }\n  return true;\n}\nfunction isSameRouteLocationParamsValue(a, b) {\n  return isArray(a) ? isEquivalentArray(a, b) : isArray(b) ? isEquivalentArray(b, a) : a === b;\n}\nfunction isEquivalentArray(a, b) {\n  return isArray(b) ? a.length === b.length && a.every((value, i) => value === b[i]) : a.length === 1 && a[0] === b;\n}\nfunction resolveRelativePath(to, from) {\n  if (to.startsWith(\"/\"))\n    return to;\n  if (!from.startsWith(\"/\")) {\n    warn(`Cannot resolve a relative location without an absolute path. Trying to resolve \"${to}\" from \"${from}\". It should look like \"/${from}\".`);\n    return to;\n  }\n  if (!to)\n    return from;\n  const fromSegments = from.split(\"/\");\n  const toSegments = to.split(\"/\");\n  const lastToSegment = toSegments[toSegments.length - 1];\n  if (lastToSegment === \"..\" || lastToSegment === \".\") {\n    toSegments.push(\"\");\n  }\n  let position = fromSegments.length - 1;\n  let toPosition;\n  let segment;\n  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {\n    segment = toSegments[toPosition];\n    if (segment === \".\")\n      continue;\n    if (segment === \"..\") {\n      if (position > 1)\n        position--;\n    } else\n      break;\n  }\n  return fromSegments.slice(0, position).join(\"/\") + \"/\" + toSegments.slice(toPosition).join(\"/\");\n}\nvar START_LOCATION_NORMALIZED = {\n  path: \"/\",\n  // TODO: could we use a symbol in the future?\n  name: void 0,\n  params: {},\n  query: {},\n  hash: \"\",\n  fullPath: \"/\",\n  matched: [],\n  meta: {},\n  redirectedFrom: void 0\n};\nvar NavigationType;\n(function(NavigationType2) {\n  NavigationType2[\"pop\"] = \"pop\";\n  NavigationType2[\"push\"] = \"push\";\n})(NavigationType || (NavigationType = {}));\nvar NavigationDirection;\n(function(NavigationDirection2) {\n  NavigationDirection2[\"back\"] = \"back\";\n  NavigationDirection2[\"forward\"] = \"forward\";\n  NavigationDirection2[\"unknown\"] = \"\";\n})(NavigationDirection || (NavigationDirection = {}));\nvar START = \"\";\nfunction normalizeBase(base) {\n  if (!base) {\n    if (isBrowser) {\n      const baseEl = document.querySelector(\"base\");\n      base = baseEl && baseEl.getAttribute(\"href\") || \"/\";\n      base = base.replace(/^\\w+:\\/\\/[^\\/]+/, \"\");\n    } else {\n      base = \"/\";\n    }\n  }\n  if (base[0] !== \"/\" && base[0] !== \"#\")\n    base = \"/\" + base;\n  return removeTrailingSlash(base);\n}\nvar BEFORE_HASH_RE = /^[^#]+#/;\nfunction createHref(base, location2) {\n  return base.replace(BEFORE_HASH_RE, \"#\") + location2;\n}\nfunction getElementPosition(el, offset) {\n  const docRect = document.documentElement.getBoundingClientRect();\n  const elRect = el.getBoundingClientRect();\n  return {\n    behavior: offset.behavior,\n    left: elRect.left - docRect.left - (offset.left || 0),\n    top: elRect.top - docRect.top - (offset.top || 0)\n  };\n}\nvar computeScrollPosition = () => ({\n  left: window.scrollX,\n  top: window.scrollY\n});\nfunction scrollToPosition(position) {\n  let scrollToOptions;\n  if (\"el\" in position) {\n    const positionEl = position.el;\n    const isIdSelector = typeof positionEl === \"string\" && positionEl.startsWith(\"#\");\n    if (typeof position.el === \"string\") {\n      if (!isIdSelector || !document.getElementById(position.el.slice(1))) {\n        try {\n          const foundEl = document.querySelector(position.el);\n          if (isIdSelector && foundEl) {\n            warn(`The selector \"${position.el}\" should be passed as \"el: document.querySelector('${position.el}')\" because it starts with \"#\".`);\n            return;\n          }\n        } catch (err) {\n          warn(`The selector \"${position.el}\" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);\n          return;\n        }\n      }\n    }\n    const el = typeof positionEl === \"string\" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;\n    if (!el) {\n      warn(`Couldn't find element using selector \"${position.el}\" returned by scrollBehavior.`);\n      return;\n    }\n    scrollToOptions = getElementPosition(el, position);\n  } else {\n    scrollToOptions = position;\n  }\n  if (\"scrollBehavior\" in document.documentElement.style)\n    window.scrollTo(scrollToOptions);\n  else {\n    window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.scrollX, scrollToOptions.top != null ? scrollToOptions.top : window.scrollY);\n  }\n}\nfunction getScrollKey(path, delta) {\n  const position = history.state ? history.state.position - delta : -1;\n  return position + path;\n}\nvar scrollPositions = /* @__PURE__ */ new Map();\nfunction saveScrollPosition(key, scrollPosition) {\n  scrollPositions.set(key, scrollPosition);\n}\nfunction getSavedScrollPosition(key) {\n  const scroll = scrollPositions.get(key);\n  scrollPositions.delete(key);\n  return scroll;\n}\nvar createBaseLocation = () => location.protocol + \"//\" + location.host;\nfunction createCurrentLocation(base, location2) {\n  const { pathname, search, hash } = location2;\n  const hashPos = base.indexOf(\"#\");\n  if (hashPos > -1) {\n    let slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;\n    let pathFromHash = hash.slice(slicePos);\n    if (pathFromHash[0] !== \"/\")\n      pathFromHash = \"/\" + pathFromHash;\n    return stripBase(pathFromHash, \"\");\n  }\n  const path = stripBase(pathname, base);\n  return path + search + hash;\n}\nfunction us... (84379 more characters)"
        }
      },
      "id": 2,
      "thread_id": 0,
      "parent_id": 1,
      "elapsed": 0.0007019170006969944
    }
  ],
  "version": "1.12",
  "metadata": {
    "client": {
      "name": "appmap-node",
      "version": "2.23.0",
      "url": "https://github.com/getappmap/appmap-node"
    },
    "language": {
      "name": "javascript",
      "engine": "Node.js",
      "version": "v20.11.1"
    },
    "app": "rdh-admin",
    "recorder": {
      "type": "requests",
      "name": "requests"
    },
    "name": "GET /node_modules/.vite/deps/vue-router.js (200) — 2024-07-13T11:59:16.336Z"
  },
  "classMap": [
    {
      "type": "http",
      "name": "HTTP server requests",
      "children": [
        {
          "type": "route",
          "name": "GET /node_modules/.vite/deps/vue-router.js"
        }
      ]
    }
  ]
}