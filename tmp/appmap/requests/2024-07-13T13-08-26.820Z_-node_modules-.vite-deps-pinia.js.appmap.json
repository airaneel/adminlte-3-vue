{
  "events": [
    {
      "event": "call",
      "http_server_request": {
        "path_info": "/node_modules/.vite/deps/pinia.js",
        "request_method": "GET",
        "headers": {
          "Host": "localhost:5173",
          "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:128.0) Gecko/20100101 Firefox/128.0",
          "Accept": "*/*",
          "Accept-Language": "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3",
          "Accept-Encoding": "gzip, deflate, br, zstd",
          "Connection": "keep-alive",
          "Referer": "http://localhost:5173/src/main.ts?t=1720874283103",
          "Cookie": "csrftoken=JoG0lboZVZucsyUC10B83fyK2PSrJqgf; _pk_id.1.1fff=76aff4dcfa6d42d0.1719754794.; accessToken=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNzIwMzczOTQ1LCJpYXQiOjE3MjAzNzM2NDUsImp0aSI6IjkyYjQzYmVjZjYxOTQyYTg5NDNjNWU2OGVjMDllYTQ3IiwidXNlcl9pZCI6MX0.9q_idMkvw61A5G6GQkM1WGfNo-jUZdncjM_JDqPh1Ps; refreshToken=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTcyMDQ2MDA0NSwiaWF0IjoxNzIwMzczNjQ1LCJqdGkiOiIwODJmMTYzMDEwNWY0YmViYTE2MjZjNjI5Y2U0ODFkMSIsInVzZXJfaWQiOjF9.Kh6m-J9pRfNqxauGr3E2UcLozG_px7iFCtCHeCHGb8I; tabstyle=html-tab; vuexy-color-scheme=dark; vuexy-isVerticalNavCollapsed=false; r-color-scheme=dark; rh-color-scheme=dark; rdh-color-scheme=dark; rdh--color-scheme=dark; rdh-corp-color-scheme=dark; rdh-corporte-color-scheme=dark; rdh-corporate-color-scheme=dark; rRD-corporate-color-scheme=dark; -corporate-color-scheme=dark; RDH-corporate-color-scheme=dark; RDH-corporate-isVerticalNavCollapsed=true; RDH-color-scheme=dark; -color-scheme=dark; R-color-scheme=dark; RDH-theme=light; RDH-corporate-theme=dark",
          "Sec-Fetch-Dest": "script",
          "Sec-Fetch-Mode": "cors",
          "Sec-Fetch-Site": "same-origin",
          "Pragma": "no-cache",
          "Cache-Control": "no-cache"
        },
        "protocol": "HTTP/1.1"
      },
      "id": 1,
      "thread_id": 0,
      "message": [
        {
          "name": "v",
          "value": "'e79d9748'",
          "class": "String"
        }
      ]
    },
    {
      "event": "return",
      "http_server_response": {
        "status_code": 200,
        "headers": {
          "Access-Control-Allow-Origin": "*",
          "Content-Type": "text/javascript",
          "Cache-Control": "max-age=31536000,immutable",
          "Etag": "W/\"b81d-1sBx8eVv6Mhsp6ABF3zrhc6gKHg\""
        },
        "return_value": {
          "class": "[ResponseBody]",
          "value": "import {\n  setupDevtoolsPlugin\n} from \"/node_modules/.vite/deps/chunk-YFT6OQ5R.js?v=e79d9748\";\nimport {\n  computed,\n  effectScope,\n  getCurrentInstance,\n  getCurrentScope,\n  hasInjectionContext,\n  inject,\n  isReactive,\n  isRef,\n  markRaw,\n  nextTick,\n  onScopeDispose,\n  reactive,\n  ref,\n  toRaw,\n  toRef,\n  toRefs,\n  unref,\n  watch\n} from \"/node_modules/.vite/deps/chunk-MGOCPVRW.js?v=e79d9748\";\nimport \"/node_modules/.vite/deps/chunk-G3PMV62Z.js?v=e79d9748\";\n\n// node_modules/pinia/node_modules/vue-demi/lib/index.mjs\nvar isVue2 = false;\nfunction set(target, key, val) {\n  if (Array.isArray(target)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val;\n  }\n  target[key] = val;\n  return val;\n}\nfunction del(target, key) {\n  if (Array.isArray(target)) {\n    target.splice(key, 1);\n    return;\n  }\n  delete target[key];\n}\n\n// node_modules/pinia/dist/pinia.mjs\nvar activePinia;\nvar setActivePinia = (pinia) => activePinia = pinia;\nvar getActivePinia = () => hasInjectionContext() && inject(piniaSymbol) || activePinia;\nvar piniaSymbol = true ? Symbol(\"pinia\") : (\n  /* istanbul ignore next */\n  Symbol()\n);\nfunction isPlainObject(o) {\n  return o && typeof o === \"object\" && Object.prototype.toString.call(o) === \"[object Object]\" && typeof o.toJSON !== \"function\";\n}\nvar MutationType;\n(function(MutationType2) {\n  MutationType2[\"direct\"] = \"direct\";\n  MutationType2[\"patchObject\"] = \"patch object\";\n  MutationType2[\"patchFunction\"] = \"patch function\";\n})(MutationType || (MutationType = {}));\nvar IS_CLIENT = typeof window !== \"undefined\";\nvar USE_DEVTOOLS = IS_CLIENT;\nvar _global = (() => typeof window === \"object\" && window.window === window ? window : typeof self === \"object\" && self.self === self ? self : typeof global === \"object\" && global.global === global ? global : typeof globalThis === \"object\" ? globalThis : { HTMLElement: null })();\nfunction bom(blob, { autoBom = false } = {}) {\n  if (autoBom && /^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(blob.type)) {\n    return new Blob([String.fromCharCode(65279), blob], { type: blob.type });\n  }\n  return blob;\n}\nfunction download(url, name, opts) {\n  const xhr = new XMLHttpRequest();\n  xhr.open(\"GET\", url);\n  xhr.responseType = \"blob\";\n  xhr.onload = function() {\n    saveAs(xhr.response, name, opts);\n  };\n  xhr.onerror = function() {\n    console.error(\"could not download file\");\n  };\n  xhr.send();\n}\nfunction corsEnabled(url) {\n  const xhr = new XMLHttpRequest();\n  xhr.open(\"HEAD\", url, false);\n  try {\n    xhr.send();\n  } catch (e) {\n  }\n  return xhr.status >= 200 && xhr.status <= 299;\n}\nfunction click(node) {\n  try {\n    node.dispatchEvent(new MouseEvent(\"click\"));\n  } catch (e) {\n    const evt = document.createEvent(\"MouseEvents\");\n    evt.initMouseEvent(\"click\", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);\n    node.dispatchEvent(evt);\n  }\n}\nvar _navigator = typeof navigator === \"object\" ? navigator : { userAgent: \"\" };\nvar isMacOSWebView = (() => /Macintosh/.test(_navigator.userAgent) && /AppleWebKit/.test(_navigator.userAgent) && !/Safari/.test(_navigator.userAgent))();\nvar saveAs = !IS_CLIENT ? () => {\n} : (\n  // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program\n  typeof HTMLAnchorElement !== \"undefined\" && \"download\" in HTMLAnchorElement.prototype && !isMacOSWebView ? downloadSaveAs : (\n    // Use msSaveOrOpenBlob as a second approach\n    \"msSaveOrOpenBlob\" in _navigator ? msSaveAs : (\n      // Fallback to using FileReader and a popup\n      fileSaverSaveAs\n    )\n  )\n);\nfunction downloadSaveAs(blob, name = \"download\", opts) {\n  const a = document.createElement(\"a\");\n  a.download = name;\n  a.rel = \"noopener\";\n  if (typeof blob === \"string\") {\n    a.href = blob;\n    if (a.origin !== location.origin) {\n      if (corsEnabled(a.href)) {\n        download(blob, name, opts);\n      } else {\n        a.target = \"_blank\";\n        click(a);\n      }\n    } else {\n      click(a);\n    }\n  } else {\n    a.href = URL.createObjectURL(blob);\n    setTimeout(function() {\n      URL.revokeObjectURL(a.href);\n    }, 4e4);\n    setTimeout(function() {\n      click(a);\n    }, 0);\n  }\n}\nfunction msSaveAs(blob, name = \"download\", opts) {\n  if (typeof blob === \"string\") {\n    if (corsEnabled(blob)) {\n      download(blob, name, opts);\n    } else {\n      const a = document.createElement(\"a\");\n      a.href = blob;\n      a.target = \"_blank\";\n      setTimeout(function() {\n        click(a);\n      });\n    }\n  } else {\n    navigator.msSaveOrOpenBlob(bom(blob, opts), name);\n  }\n}\nfunction fileSaverSaveAs(blob, name, opts, popup) {\n  popup = popup || open(\"\", \"_blank\");\n  if (popup) {\n    popup.document.title = popup.document.body.innerText = \"downloading...\";\n  }\n  if (typeof blob === \"string\")\n    return download(blob, name, opts);\n  const force = blob.type === \"application/octet-stream\";\n  const isSafari = /constructor/i.test(String(_global.HTMLElement)) || \"safari\" in _global;\n  const isChromeIOS = /CriOS\\/[\\d]+/.test(navigator.userAgent);\n  if ((isChromeIOS || force && isSafari || isMacOSWebView) && typeof FileReader !== \"undefined\") {\n    const reader = new FileReader();\n    reader.onloadend = function() {\n      let url = reader.result;\n      if (typeof url !== \"string\") {\n        popup = null;\n        throw new Error(\"Wrong reader.result type\");\n      }\n      url = isChromeIOS ? url : url.replace(/^data:[^;]*;/, \"data:attachment/file;\");\n      if (popup) {\n        popup.location.href = url;\n      } else {\n        location.assign(url);\n      }\n      popup = null;\n    };\n    reader.readAsDataURL(blob);\n  } else {\n    const url = URL.createObjectURL(blob);\n    if (popup)\n      popup.location.assign(url);\n    else\n      location.href = url;\n    popup = null;\n    setTimeout(function() {\n      URL.revokeObjectURL(url);\n    }, 4e4);\n  }\n}\nfunction toastMessage(message, type) {\n  const piniaMessage = \"üçç \" + message;\n  if (typeof __VUE_DEVTOOLS_TOAST__ === \"function\") {\n    __VUE_DEVTOOLS_TOAST__(piniaMessage, type);\n  } else if (type === \"error\") {\n    console.error(piniaMessage);\n  } else if (type === \"warn\") {\n    console.warn(piniaMessage);\n  } else {\n    console.log(piniaMessage);\n  }\n}\nfunction isPinia(o) {\n  return \"_a\" in o && \"install\" in o;\n}\nfunction checkClipboardAccess() {\n  if (!(\"clipboard\" in navigator)) {\n    toastMessage(`Your browser doesn't support the Clipboard API`, \"error\");\n    return true;\n  }\n}\nfunction checkNotFocusedError(error) {\n  if (error instanceof Error && error.message.toLowerCase().includes(\"document is not focused\")) {\n    toastMessage('You need to activate the \"Emulate a focused page\" setting in the \"Rendering\" panel of devtools.', \"warn\");\n    return true;\n  }\n  return false;\n}\nasync function actionGlobalCopyState(pinia) {\n  if (checkClipboardAccess())\n    return;\n  try {\n    await navigator.clipboard.writeText(JSON.stringify(pinia.state.value));\n    toastMessage(\"Global state copied to clipboard.\");\n  } catch (error) {\n    if (checkNotFocusedError(error))\n      return;\n    toastMessage(`Failed to serialize the state. Check the console for more details.`, \"error\");\n    console.error(error);\n  }\n}\nasync function actionGlobalPasteState(pinia) {\n  if (checkClipboardAccess())\n    return;\n  try {\n    loadStoresState(pinia, JSON.parse(await navigator.clipboard.readText()));\n    toastMessage(\"Global state pasted from clipboard.\");\n  } catch (error) {\n    if (checkNotFocusedError(error))\n      return;\n    toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, \"error\");\n    console.error(error);\n  }\n}\nasync function actionGlobalSaveState(pinia) {\n  try {\n    saveAs(new Blob([JSON.stringify(pinia.state.value)], {\n      type: \"text/plain;charset=utf-8\"\n    }), \"pinia-state.json\");\n  } catch (error) {\n    toastMessage(`Failed to export the state as JSON. Check the console for more details.`, \"error\");\n    console.error(error);\n  }\n}\nvar fileInput;\nfunction getFileOpener() {\n  if (!fileInput) {\n    fileInput = document.createElement(\"input\");\n    fileInput.type = \"file\";\n    fileInput.accept = \".json\";\n  }\n  function openFile() {\n    return new Promise((resolve, reject) => {\n      fileInput.onchange = async () => {\n        const files = fileInput.files;\n        if (!files)\n          return resolve(null);\n        const file = files.item(0);\n        if (!file)\n          return resolve(null);\n        return resolve({ text: await file.text(), file });\n      };\n      fileInput.oncancel = () => resolve(null);\n      fileInput.onerror = reject;\n      fileInput.click();\n    });\n  }\n  return openFile;\n}\nasync function actionGlobalOpenStateFile(pinia) {\n  try {\n    const open2 = getFileOpener();\n    const result = await open2();\n    if (!result)\n      return;\n    const { text, file } = result;\n    loadStoresState(pinia, JSON.parse(text));\n    toastMessage(`Global state imported from \"${file.name}\".`);\n  } catch (error) {\n    toastMessage(`Failed to import the state from JSON. Check the console for more details.`, \"error\");\n    console.error(error);\n  }\n}\nfunction loadStoresState(pinia, state) {\n  for (const key in state) {\n    const storeState = pinia.state.value[key];\n    if (storeState) {\n      Object.assign(storeState, state[key]);\n    } else {\n      pinia.state.value[key] = state[key];\n    }\n  }\n}\nfunction formatDisplay(display) {\n  return {\n    _custom: {\n      display\n    }\n  };\n}\nvar PINIA_ROOT_LABEL = \"üçç Pinia (root)\";\nvar PINIA_ROOT_ID = \"_root\";\nfunction formatStoreForInspectorTree(store) {\n  return isPinia(store) ? {\n    id: PINIA_ROOT_ID,\n    label: PINIA_ROOT_LABEL\n  } : {\n    id: store.$id,\n    label: store.$id\n  };\n}\nfunction formatStoreForInspectorState(store) {\n  if (isPinia(store)) {\n    const storeNames = Array.from(store._s.keys());\n    const storeMap = store._s;\n    const state2 = {\n      state: storeNames.map((storeId) => ({\n        editable: true,\n        key: storeId,\n      ... (37079 more characters)"
        }
      },
      "id": 2,
      "thread_id": 0,
      "parent_id": 1,
      "elapsed": 0.0004090839938726276
    }
  ],
  "version": "1.12",
  "metadata": {
    "client": {
      "name": "appmap-node",
      "version": "2.23.0",
      "url": "https://github.com/getappmap/appmap-node"
    },
    "language": {
      "name": "javascript",
      "engine": "Node.js",
      "version": "v20.11.1"
    },
    "app": "rdh-admin",
    "recorder": {
      "type": "requests",
      "name": "requests"
    },
    "name": "GET /node_modules/.vite/deps/pinia.js (200) ‚Äî 2024-07-13T13:08:26.820Z"
  },
  "classMap": [
    {
      "type": "http",
      "name": "HTTP server requests",
      "children": [
        {
          "type": "route",
          "name": "GET /node_modules/.vite/deps/pinia.js"
        }
      ]
    }
  ]
}